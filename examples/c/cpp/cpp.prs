PARSER Pars

GLOBAL {

    /* Copyright (C) 1989-1991 James A. Roskind, All rights reserved. 
    This grammar was developed  and  written  by  James  A.  Roskind. 
    Copying  of  this  grammar  description, as a whole, is permitted 
    providing this notice is intact and applicable  in  all  complete 
    copies.   Translations as a whole to other parser generator input 
    languages  (or  grammar  description  languages)   is   permitted 
    provided  that  this  notice is intact and applicable in all such 
    copies,  along  with  a  disclaimer  that  the  contents  are   a 
    translation.   The reproduction of derived text, such as modified 
    versions of this grammar, or the output of parser generators,  is 
    permitted,  provided  the  resulting  work includes the copyright 
    notice "Portions Copyright (c)  1989,  1990  James  A.  Roskind". 
    Derived products, such as compilers, translators, browsers, etc., 
    that  use  this  grammar,  must also provide the notice ""Portions 
    Copyright  (c)  1989,  1990  James  A.  Roskind""  in   a   manner 
    appropriate  to  the  utility,  and in keeping with copyright law 
    (e.g.: EITHER displayed when first invoked/executed; OR displayed 
    continuously on display terminal; OR via placement in the  object 
    code  in  form  readable in a printout, with or near the title of 
    the work, or at the end of the file).  No royalties, licenses  or 
    commissions  of  any  kind are required to copy this grammar, its 
    translations, or derivative products, when the copies are made in 
    compliance with this notice. Persons or corporations that do make 
    copies in compliance with this notice may charge  whatever  price 
    is  agreeable  to  a  buyer, for such copies or derivative works. 
    this GRAMMAR IS PROVIDED ``AS IS'' AND  WITHOUT  ANY  EXPRESS  OR 
    IMPLIED  WARRANTIES,  INCLUDING,  WITHOUT LIMITATION, THE IMPLIED 
    WARRANTIES  OF  MERCHANTABILITY  AND  FITNESS  FOR  A  PARTICULAR 
    PURPOSE.

    James A. Roskind
    Independent Consultant
    516 Latania Palm Drive
    Indialantic FL, 32903
    (407)729-4348
    jar@hq.ileaf.com


    ---end of copyright notice---

MOTIVATION-

My  goal  is  to  see  software  developers  adopt  this grammar as a 
standard until such time as a better  standard  is  accessible.   The 
only  way  to  get it to become a standard, is to be sure that people 
know that derivations are based on a specific work.   The  intent  of 
releasing  this  grammar is to provide a publicly accessible standard 
grammar for C++.  The intent of the  copyright  notice  is  to  allow 
arbitrary  commercial  and non-commercial use of the grammar, as long 
as reference is given to the original standard.  Without reference to 
a specific standard, many alternative  grammars  would  develop.   By 
referring  to  the  standard,  this grammar is given publicity, which 
should lead to further use in compatible products and  systems.   The 
benefits  of  such  a  standard  to  commercial  products  (browsers, 
beautifiers, translators, compilers, ...) should be  obvious  to  the 
developers,  in  that  other compatible products will emerge, and the 
value of all conforming products  will  rise.   Most  developers  are 
aware  of  the  value  of  acquiring  a fairly complete grammar for a 
language, and the copyright notice  (and  the  resulting  affiliation 
with my work) should not be too high a price to pay.  By copyrighting 
this  grammar,  I have some minor control over what this standard is, 
and I can (hopefully) keep it from degrading without my approval.   I 
will  consistently  attempt  to  provide  upgraded  grammars that are 
compliant  with  the  current  art,  and  the  ANSI   C++   Committee 
recommendation  in  particular.   A developer is never prevented from 
modifying the grammar to improve it in  whatever  way  is  seen  fit.  
There  is  also  no  restriction on the sale of copies, or derivative 
works, providing the requests in the copyright notice are satisfied.

If you are not "copying" my work, but  are  rather  only  abstracting 
some  of  the  standard,  an acknowledgment with references to such a 
standard would be appreciated.  Specifically,  agreements  with  this 
standard  as  to  the  resolution  of otherwise ambiguous constructs, 
should be noted.

Simply put: ""make whatever use you would like  of  the  grammar,  but 
include  the  ``portions  Copyright  ...''  as  a  reference  to this 
standard.""

*/

/* Last modified 7/4/91, Version 2.0  */

/*  ACKNOWLEDGMENT: Without Bjarne Stroustrup and his many co-workers 
at Bell Labs, there would be no C++ Language for which to  provide  a 
syntax  description. Bjarne has also been especially helpful and open 
in discussions, and by permitting me to review  his  texts  prior  to 
their publication, allowed me a wonderful vantage point of clarity.

Without  the effort expended by the ANSI C standardizing committee, I 
would have been lost.  Although the ANSI C standard does not  include 
a  fully disambiguated syntax description, the committee has at least 
provided most of the disambiguating rules in  narratives.   This  C++ 
grammar  is intended to be a superset of an ANSI C compatible grammar 
that is provided in an related file.

Several reviewers have also  recently  critiqued  this  grammar,  the 
related  C  grammar,  and  or  assisted  in  discussions  during it''s 
preparation.  These reviewers are certainly not responsible  for  the 
errors  I  have committed here, but they are responsible for allowing 
me  to  provide  fewer  errors.   These  colleagues  include:   Bruce 
Blodgett,  Mark Langley, Joe Fialli, Greg Perkins, Ron Guilmette, and 
Eric Krohn. */

/* Required fixes from last release :

done: 0) Allow direct call to destructors

done: 1) Allow placement of declarations in labeled statements.   The 
easiest  fix involves using a larger variance from the C grammar, and 
simply making "statement" include declarations.  Note that it  should 
also  be  legal  for  declarations  to  be  in  the  branches  of  if 
statements, as long as there is no other code in the block (I think).  
Consider:

        ...
        {
           if (0 == a)
                int b=5;
           else
                int c=4;
         }

1) template support: Not  done:  pending  syntax  specification  from 
ANSI.  (This looks like a major effort, as ANSI has decided to extend 
the  "TYPEDEFname"-feedback-to-the-lexer-hack  to  support   template 
names as a new kind of terminal token.)

2)  exception  handling:  Not done: pending syntax specification from 
ANSI (but it doesn''t look hard)

done: 3) Support nested types, including identifier::name,  where  we 
realize  that  identifier was a hidden type.  Force the lexer to keep 
pace in this situation.   This  will  require  an  extension  of  the 
yacc-lex feedback loop.

done: 4) Support nested types even when derivations are used in class 
definitions.

5)  Provide  advanced  tutorial  on  YACC  conflicts:  almost done in 
documentation about machine generated documentation.

done: 6) Allow declaration specifiers to be left out of  declarations 
at file and structure scope so that operator conversion functions can 
be  declared and/or defined.  Note that checking to see that it was a 
function type that does not require declaration_specifiers is  now  a 
constraint  check,  and  not  a  syntax  issue.  Within function body 
scopes, declaration specifiers are required, and this is critical  to 
distinguishing expressions.


*/


/*

Interesting ambiguity:
Usually
        typename ( typename2 ) ...
or
        typename ( typename2 [4] ) ...
etc.
is a redeclaration of typename2.

Inside  a structure elaboration, it is sometimes the declaration of a 
constructor!  Note, this only  counts  if  typename  IS  the  current 
containing  class name. (Note this can''t conflict with ANSI C because 
ANSI C would call it a redefinition, but  claim  it  is  semantically 
illegal because you can''t have a member declared the same type as the 
containing struct!) Since the ambiguity is only reached when a ';' is 
found,   there  is  no  problem  with  the  fact  that  the  semantic 
interpretation  is  providing  the  true  resolution.   As  currently 
implemented, the constructor semantic actions must be able to process 
an  ordinary  declaration.  I may reverse this in the future, to ease 
semantic implementation.

*/
/*

INTRO TO ANSI C GRAMMAR (provided in a separate file):

The refined grammar resolves several typedef ambiguities in the draft 
proposed ANSI C standard syntax down to 1 shift/reduce  conflict,  as 
reported by a YACC process.  Note that the one shift reduce conflicts 
is  the  traditional  if-if-else conflict that is not resolved by the 
grammar.  This ambiguity can be removed using the method described in 
the Dragon Book (2nd edition), but this does  not  appear  worth  the 
effort.

There  was quite a bit of effort made to reduce the conflicts to this 
level, and an additional effort was made to make  the  grammar  quite 
similar  to  the  C++ grammar being developed in parallel.  Note that 
this grammar resolves the following ANSI C ambiguities:

ANSI C section 3.5.6, ""If the [typedef  name]  is  redeclared  at  an 
inner  scope,  the  type specifiers shall not be omitted in the inner 
declaration"".  Supplying type specifiers prevents consideration of  T 
as a typedef name in this grammar.  Failure to supply type specifiers 
forced the use of the TYPEDEFname as a type specifier.  This is taken 
to an (unnecessary) extreme by this implementation.  The ambiguity is 
only  a  problem  with  the first declarator in a declaration, but we 
restrict  ALL  declarators  whenever  the  users  fails  to   use   a 
type_specifier.

ANSI C section 3.5.4.3, ""In a parameter declaration, a single typedef 
name  in  parentheses  is  taken  to  be  an abstract declarator that 
specifies a function  with  a  single  parameter,  not  as  redundant 
parentheses  around  the  identifier"".  This is extended to cover the 
following cases:

typedef float T;
int noo(const (T[5]));
int moo(const (T(int)));
...

Where again the '(' immediately to the left of 'T' is interpreted  as 
being  the  start  of  a  parameter type list, and not as a redundant 
paren around a redeclaration of T.  Hence an equivalent code fragment 
is:

typedef float T;
int noo(const int identifier1 (T identifier2 [5]));
int moo(const int identifier1 (T identifier2 (int identifier3)));
...

*/

/*************** Includes and Defines *****************************/
#define YYDEBUG_LEXER_TEXT (yylval) /* our lexer loads this up each time.
				     We are telling the graphical debugger
				     where to find the spelling of the 
				     tokens.*/
#define YYDEBUG 1        /* get the pretty debugging code to compile*/
#define YYSTYPE  char *  /* interface with flex: should be in header file */

/*************** Standard ytab.c continues here *********************/

/*************************************************************************/
/* This group is used by the C/C++ language parser */
/* The following are used in C++ only.  ANSI C would call these IDENTIFIERs */
/* ANSI C Grammar suggestions */
/* New Lexical element, whereas ANSI C suggested non-terminal */
/* Multi-Character operators */
/*    ->                              */
/*    ++      --                      */
/*    <<      >>                      */
/*    <=      >=      ==      !=      */
/*    &&      ||                      */
/*    ...                             */
/* Following are used in C++, not ANSI C        */
/*    ::                              */
/*    .*       ->*                    */
/* modifying assignment operators */
/*   *=      /=      %=      */
/*   +=      -=              */
/*   <<=     >>=             */
/*   &=      ^=      |=      */
/*************************************************************************/
}

RULE

__START__	= translation_unit .

constant	= <
		= INTEGERconstant .
		= FLOATINGconstant .
		= OCTALconstant .
		= HEXconstant .
		= CHARACTERconstant .
> .
string_literal_list	= <
		= STRINGliteral .
		= string_literal_list STRINGliteral .
> .
paren_identifier_declarator	= <
		= scope_opt_identifier .
		= scope_opt_complex_name .
		= '(' paren_identifier_declarator ')' .
> .
primary_expression	= <
		= global_opt_scope_opt_identifier .
		= global_opt_scope_opt_complex_name .
		= this .
		= constant .
		= string_literal_list .
		= '(' comma_expression ')' .
> .
non_elaborating_type_specifier	= <
		= sue_type_specifier .
		= basic_type_specifier .
		= typedef_type_specifier .
		= basic_type_name .
		= TYPEDEFname .
		= global_or_scoped_typedefname .
> .
operator_function_name	= <
		= operator any_operator .
		= operator type_qualifier_list operator_function_ptr_opt .
		= operator non_elaborating_type_specifier operator_function_ptr_opt .
> .
operator_function_ptr_opt	= <
		= .
		= unary_modifier operator_function_ptr_opt .
		= asterisk_or_ampersand operator_function_ptr_opt .
> .
any_operator	= <
		= '+' .
		= '-' .
		= '*' .
		= '/' .
		= '%' .
		= '^' .
		= '&' .
		= '|' .
		= '~' .
		= '!' .
		= '<' .
		= '>' .
		= '<<' .
		= '>>' .
		= '&&' .
		= '||' .
		= '->' .
		= '->*' .
		= '.' .
		= '.*' .
		= '++' .
		= '--' .
		= '<=' .
		= '>=' .
		= '==' .
		= '!=' .
		= assignment_operator .
		= '(' ')' .
		= '[' ']' .
		= new .
		= delete .
		= ',' .
> .
type_qualifier_list_opt	= <
		= .
		= type_qualifier_list .
> .
postfix_expression	= <
		= primary_expression .
		= postfix_expression '[' comma_expression ']' .
		= postfix_expression '(' ')' .
		= postfix_expression '(' argument_expression_list ')' .
		= postfix_expression '.' member_name .
		= postfix_expression '->' member_name .
		= postfix_expression '++' .
		= postfix_expression '--' .
		= TYPEDEFname '(' ')' .
		= global_or_scoped_typedefname '(' ')' .
		= TYPEDEFname '(' argument_expression_list ')' .
		= global_or_scoped_typedefname '(' argument_expression_list ')' .
		= basic_type_name '(' assignment_expression ')' .
> .
member_name	= <
		= scope_opt_identifier .
		= scope_opt_complex_name .
		= basic_type_name '::' '~' basic_type_name .
		= declaration_qualifier_list '::' '~' declaration_qualifier_list .
		= type_qualifier_list '::' '~' type_qualifier_list .
> .
argument_expression_list	= <
		= assignment_expression .
		= argument_expression_list ',' assignment_expression .
> .
unary_expression	= <
		= postfix_expression .
		= '++' unary_expression .
		= '--' unary_expression .
		= asterisk_or_ampersand cast_expression .
		= '-' cast_expression .
		= '+' cast_expression .
		= '~' cast_expression .
		= '!' cast_expression .
		= sizeof unary_expression .
		= sizeof '(' type_name ')' .
		= allocation_expression .
> .
allocation_expression	= <
		= global_opt_scope_opt_operator_new '(' type_name ')' operator_new_initializer_opt .
		= global_opt_scope_opt_operator_new '(' argument_expression_list ')' '(' type_name ')' operator_new_initializer_opt .
		= global_opt_scope_opt_operator_new operator_new_type .
		= global_opt_scope_opt_operator_new '(' argument_expression_list ')' operator_new_type .
> .
global_opt_scope_opt_operator_new	= <
		= new .
		= global_or_scope new .
> .
operator_new_type	= <
		= type_qualifier_list operator_new_declarator_opt operator_new_initializer_opt .
		= non_elaborating_type_specifier operator_new_declarator_opt operator_new_initializer_opt .
> .
operator_new_declarator_opt	= <
		= .
		= operator_new_array_declarator .
		= asterisk_or_ampersand operator_new_declarator_opt .
		= unary_modifier operator_new_declarator_opt .
> .
operator_new_array_declarator	= <
		= '[' ']' .
		= '[' comma_expression ']' .
		= operator_new_array_declarator '[' comma_expression ']' .
> .
operator_new_initializer_opt	= <
		= .
		= '(' ')' .
		= '(' argument_expression_list ')' .
> .
cast_expression	= <
		= unary_expression .
		= '(' type_name ')' cast_expression .
> .
deallocation_expression	= <
		= cast_expression .
		= global_opt_scope_opt_delete deallocation_expression .
		= global_opt_scope_opt_delete '[' comma_expression ']' deallocation_expression .
		= global_opt_scope_opt_delete '[' ']' deallocation_expression .
> .
global_opt_scope_opt_delete	= <
		= delete .
		= global_or_scope delete .
> .
point_member_expression	= <
		= deallocation_expression .
		= point_member_expression '.*' deallocation_expression .
		= point_member_expression '->*' deallocation_expression .
> .
multiplicative_expression	= <
		= point_member_expression .
		= multiplicative_expression '*' point_member_expression .
		= multiplicative_expression '/' point_member_expression .
		= multiplicative_expression '%' point_member_expression .
> .
additive_expression	= <
		= multiplicative_expression .
		= additive_expression '+' multiplicative_expression .
		= additive_expression '-' multiplicative_expression .
> .
shift_expression	= <
		= additive_expression .
		= shift_expression '<<' additive_expression .
		= shift_expression '>>' additive_expression .
> .
relational_expression	= <
		= shift_expression .
		= relational_expression '<' shift_expression .
		= relational_expression '>' shift_expression .
		= relational_expression '<=' shift_expression .
		= relational_expression '>=' shift_expression .
> .
equality_expression	= <
		= relational_expression .
		= equality_expression '==' relational_expression .
		= equality_expression '!=' relational_expression .
> .
AND_expression	= <
		= equality_expression .
		= AND_expression '&' equality_expression .
> .
exclusive_OR_expression	= <
		= AND_expression .
		= exclusive_OR_expression '^' AND_expression .
> .
inclusive_OR_expression	= <
		= exclusive_OR_expression .
		= inclusive_OR_expression '|' exclusive_OR_expression .
> .
logical_AND_expression	= <
		= inclusive_OR_expression .
		= logical_AND_expression '&&' inclusive_OR_expression .
> .
logical_OR_expression	= <
		= logical_AND_expression .
		= logical_OR_expression '||' logical_AND_expression .
> .
conditional_expression	= <
		= logical_OR_expression .
		= logical_OR_expression '?' comma_expression ':' conditional_expression .
> .
assignment_expression	= <
		= conditional_expression .
		= unary_expression assignment_operator assignment_expression .
> .
assignment_operator	= <
		= '=' .
		= '*=' .
		= '/=' .
		= '%=' .
		= '+=' .
		= '-=' .
		= '<<=' .
		= '>>=' .
		= '&=' .
		= '^=' .
		= '|=' .
> .
comma_expression	= <
		= assignment_expression .
		= comma_expression ',' assignment_expression .
> .
constant_expression	= conditional_expression .

comma_expression_opt	= <
		= .
		= comma_expression .
> .
declaration	= <
		= declaring_list ';' .
		= default_declaring_list ';' .
		= sue_declaration_specifier ';' .
		= sue_type_specifier ';' .
		= sue_type_specifier_elaboration ';' .
> .
default_declaring_list	= <
		= declaration_qualifier_list identifier_declarator initializer_opt .
		= type_qualifier_list identifier_declarator initializer_opt .
		= default_declaring_list ',' identifier_declarator initializer_opt .
		= declaration_qualifier_list constructed_identifier_declarator .
		= type_qualifier_list constructed_identifier_declarator .
		= default_declaring_list ',' constructed_identifier_declarator .
> .
declaring_list	= <
		= declaration_specifier declarator initializer_opt .
		= type_specifier declarator initializer_opt .
		= basic_type_name declarator initializer_opt .
		= TYPEDEFname declarator initializer_opt .
		= global_or_scoped_typedefname declarator initializer_opt .
		= declaring_list ',' declarator initializer_opt .
		= declaration_specifier constructed_declarator .
		= type_specifier constructed_declarator .
		= basic_type_name constructed_declarator .
		= TYPEDEFname constructed_declarator .
		= global_or_scoped_typedefname constructed_declarator .
		= declaring_list ',' constructed_declarator .
> .
constructed_declarator	= <
		= nonunary_constructed_identifier_declarator .
		= constructed_paren_typedef_declarator .
		= simple_paren_typedef_declarator '(' argument_expression_list ')' .
		= simple_paren_typedef_declarator postfixing_abstract_declarator '(' argument_expression_list ')' .
		= constructed_parameter_typedef_declarator .
		= asterisk_or_ampersand constructed_declarator .
		= unary_modifier constructed_declarator .
> .
constructed_paren_typedef_declarator	= <
		= '(' paren_typedef_declarator ')' '(' argument_expression_list ')' .
		= '(' paren_typedef_declarator ')' postfixing_abstract_declarator '(' argument_expression_list ')' .
		= '(' simple_paren_typedef_declarator postfixing_abstract_declarator ')' '(' argument_expression_list ')' .
		= '(' TYPEDEFname postfixing_abstract_declarator ')' '(' argument_expression_list ')' .
> .
constructed_parameter_typedef_declarator	= <
		= TYPEDEFname '(' argument_expression_list ')' .
		= TYPEDEFname postfixing_abstract_declarator '(' argument_expression_list ')' .
		= '(' clean_typedef_declarator ')' '(' argument_expression_list ')' .
		= '(' clean_typedef_declarator ')' postfixing_abstract_declarator '(' argument_expression_list ')' .
> .
constructed_identifier_declarator	= <
		= nonunary_constructed_identifier_declarator .
		= asterisk_or_ampersand constructed_identifier_declarator .
		= unary_modifier constructed_identifier_declarator .
> .
nonunary_constructed_identifier_declarator	= <
		= paren_identifier_declarator '(' argument_expression_list ')' .
		= paren_identifier_declarator postfixing_abstract_declarator '(' argument_expression_list ')' .
		= '(' unary_identifier_declarator ')' '(' argument_expression_list ')' .
		= '(' unary_identifier_declarator ')' postfixing_abstract_declarator '(' argument_expression_list ')' .
> .
declaration_specifier	= <
		= basic_declaration_specifier .
		= sue_declaration_specifier .
		= typedef_declaration_specifier .
> .
type_specifier	= <
		= basic_type_specifier .
		= sue_type_specifier .
		= sue_type_specifier_elaboration .
		= typedef_type_specifier .
> .
declaration_qualifier_list	= <
		= storage_class .
		= type_qualifier_list storage_class .
		= declaration_qualifier_list declaration_qualifier .
> .
type_qualifier_list	= <
		= type_qualifier .
		= type_qualifier_list type_qualifier .
> .
declaration_qualifier	= <
		= storage_class .
		= type_qualifier .
> .
type_qualifier	= <
		= const .
		= volatile .
> .
basic_declaration_specifier	= <
		= declaration_qualifier_list basic_type_name .
		= basic_type_specifier storage_class .
		= basic_type_name storage_class .
		= basic_declaration_specifier declaration_qualifier .
		= basic_declaration_specifier basic_type_name .
> .
basic_type_specifier	= <
		= type_qualifier_list basic_type_name .
		= basic_type_name basic_type_name .
		= basic_type_name type_qualifier .
		= basic_type_specifier type_qualifier .
		= basic_type_specifier basic_type_name .
> .
sue_declaration_specifier	= <
		= declaration_qualifier_list elaborated_type_name .
		= declaration_qualifier_list elaborated_type_name_elaboration .
		= sue_type_specifier storage_class .
		= sue_type_specifier_elaboration storage_class .
		= sue_declaration_specifier declaration_qualifier .
> .
sue_type_specifier_elaboration	= <
		= elaborated_type_name_elaboration .
		= type_qualifier_list elaborated_type_name_elaboration .
		= sue_type_specifier_elaboration type_qualifier .
> .
sue_type_specifier	= <
		= elaborated_type_name .
		= type_qualifier_list elaborated_type_name .
		= sue_type_specifier type_qualifier .
> .
typedef_declaration_specifier	= <
		= declaration_qualifier_list TYPEDEFname .
		= declaration_qualifier_list global_or_scoped_typedefname .
		= typedef_type_specifier storage_class .
		= TYPEDEFname storage_class .
		= global_or_scoped_typedefname storage_class .
		= typedef_declaration_specifier declaration_qualifier .
> .
typedef_type_specifier	= <
		= type_qualifier_list TYPEDEFname .
		= type_qualifier_list global_or_scoped_typedefname .
		= TYPEDEFname type_qualifier .
		= global_or_scoped_typedefname type_qualifier .
		= typedef_type_specifier type_qualifier .
> .
storage_class	= <
		= extern .
		= typedef .
		= static .
		= auto .
		= register .
		= friend .
		= overload .
		= inline .
		= virtual .
> .
basic_type_name	= <
		= int .
		= char .
		= short .
		= long .
		= float .
		= double .
		= signed .
		= unsigned .
		= void .
> .
elaborated_type_name_elaboration	= <
		= aggregate_name_elaboration .
		= enum_name_elaboration .
> .
elaborated_type_name	= <
		= aggregate_name .
		= enum_name .
> .
aggregate_name_elaboration	= <
		= aggregate_name derivation_opt '{' member_declaration_list_opt '}' .
		= aggregate_key derivation_opt '{' member_declaration_list_opt '}' .
> .
aggregate_name	= <
		= aggregate_key tag_name .
		= global_scope scope aggregate_key tag_name .
		= global_scope aggregate_key tag_name .
		= scope aggregate_key tag_name .
> .
derivation_opt	= <
		= .
		= ':' derivation_list .
> .
derivation_list	= <
		= parent_class .
		= derivation_list ',' parent_class .
> .
parent_class	= <
		= global_opt_scope_opt_typedefname .
		= virtual access_specifier_opt global_opt_scope_opt_typedefname .
		= access_specifier virtual_opt global_opt_scope_opt_typedefname .
> .
virtual_opt	= <
		= .
		= virtual .
> .
access_specifier_opt	= <
		= .
		= access_specifier .
> .
access_specifier	= <
		= public .
		= private .
		= protected .
> .
aggregate_key	= <
		= struct .
		= union .
		= class .
> .
member_declaration_list_opt	= <
		= .
		= member_declaration_list_opt member_declaration .
> .
member_declaration	= <
		= member_declaring_list ';' .
		= member_default_declaring_list ';' .
		= access_specifier ':' .
		= new_function_definition .
		= constructor_function_in_class .
		= sue_type_specifier ';' .
		= sue_type_specifier_elaboration ';' .
		= identifier_declarator ';' .
		= typedef_declaration_specifier ';' .
		= sue_declaration_specifier ';' .
> .
member_default_declaring_list	= <
		= type_qualifier_list identifier_declarator member_pure_opt .
		= declaration_qualifier_list identifier_declarator member_pure_opt .
		= member_default_declaring_list ',' identifier_declarator member_pure_opt .
		= type_qualifier_list bit_field_identifier_declarator .
		= declaration_qualifier_list bit_field_identifier_declarator .
		= member_default_declaring_list ',' bit_field_identifier_declarator .
> .
member_declaring_list	= <
		= type_specifier declarator member_pure_opt .
		= basic_type_name declarator member_pure_opt .
		= global_or_scoped_typedefname declarator member_pure_opt .
		= member_conflict_declaring_item .
		= member_declaring_list ',' declarator member_pure_opt .
		= type_specifier bit_field_declarator .
		= basic_type_name bit_field_declarator .
		= TYPEDEFname bit_field_declarator .
		= global_or_scoped_typedefname bit_field_declarator .
		= declaration_specifier bit_field_declarator .
		= member_declaring_list ',' bit_field_declarator .
> .
member_conflict_declaring_item	= <
		= TYPEDEFname identifier_declarator member_pure_opt .
		= TYPEDEFname parameter_typedef_declarator member_pure_opt .
		= TYPEDEFname simple_paren_typedef_declarator member_pure_opt .
		= declaration_specifier identifier_declarator member_pure_opt .
		= declaration_specifier parameter_typedef_declarator member_pure_opt .
		= declaration_specifier simple_paren_typedef_declarator member_pure_opt .
		= member_conflict_paren_declaring_item .
> .
member_conflict_paren_declaring_item	= <
		= TYPEDEFname asterisk_or_ampersand '(' simple_paren_typedef_declarator ')' member_pure_opt .
		= TYPEDEFname unary_modifier '(' simple_paren_typedef_declarator ')' member_pure_opt .
		= TYPEDEFname asterisk_or_ampersand '(' TYPEDEFname ')' member_pure_opt .
		= TYPEDEFname unary_modifier '(' TYPEDEFname ')' member_pure_opt .
		= TYPEDEFname asterisk_or_ampersand paren_typedef_declarator member_pure_opt .
		= TYPEDEFname unary_modifier paren_typedef_declarator member_pure_opt .
		= declaration_specifier asterisk_or_ampersand '(' simple_paren_typedef_declarator ')' member_pure_opt .
		= declaration_specifier unary_modifier '(' simple_paren_typedef_declarator ')' member_pure_opt .
		= declaration_specifier asterisk_or_ampersand '(' TYPEDEFname ')' member_pure_opt .
		= declaration_specifier unary_modifier '(' TYPEDEFname ')' member_pure_opt .
		= declaration_specifier asterisk_or_ampersand paren_typedef_declarator member_pure_opt .
		= declaration_specifier unary_modifier paren_typedef_declarator member_pure_opt .
		= member_conflict_paren_postfix_declaring_item .
> .
member_conflict_paren_postfix_declaring_item	= <
		= TYPEDEFname '(' paren_typedef_declarator ')' member_pure_opt .
		= TYPEDEFname '(' simple_paren_typedef_declarator postfixing_abstract_declarator ')' member_pure_opt .
		= TYPEDEFname '(' TYPEDEFname postfixing_abstract_declarator ')' member_pure_opt .
		= TYPEDEFname '(' paren_typedef_declarator ')' postfixing_abstract_declarator member_pure_opt .
		= declaration_specifier '(' paren_typedef_declarator ')' member_pure_opt .
		= declaration_specifier '(' simple_paren_typedef_declarator postfixing_abstract_declarator ')' member_pure_opt .
		= declaration_specifier '(' TYPEDEFname postfixing_abstract_declarator ')' member_pure_opt .
		= declaration_specifier '(' paren_typedef_declarator ')' postfixing_abstract_declarator member_pure_opt .
> .
member_pure_opt	= <
		= .
		= '=' OCTALconstant .
> .
bit_field_declarator	= <
		= bit_field_identifier_declarator .
		= TYPEDEFname ':' constant_expression .
> .
bit_field_identifier_declarator	= <
		= ':' constant_expression .
		= identifier_declarator ':' constant_expression .
> .
enum_name_elaboration	= <
		= global_opt_scope_opt_enum_key '{' enumerator_list '}' .
		= enum_name '{' enumerator_list '}' .
> .
enum_name	= global_opt_scope_opt_enum_key tag_name .

global_opt_scope_opt_enum_key	= <
		= enum .
		= global_or_scope enum .
> .
enumerator_list	= <
		= enumerator_list_no_trailing_comma .
		= enumerator_list_no_trailing_comma ',' .
> .
enumerator_list_no_trailing_comma	= <
		= enumerator_name enumerator_value_opt .
		= enumerator_list_no_trailing_comma ',' enumerator_name enumerator_value_opt .
> .
enumerator_name	= <
		= IDENTIFIER .
		= TYPEDEFname .
> .
enumerator_value_opt	= <
		= .
		= '=' constant_expression .
> .
parameter_type_list	= <
		= '(' ')' type_qualifier_list_opt .
		= '(' type_name ')' type_qualifier_list_opt .
		= '(' type_name initializer ')' type_qualifier_list_opt .
		= '(' named_parameter_type_list ')' type_qualifier_list_opt .
> .
old_parameter_type_list	= <
		= '(' ')' .
		= '(' type_name ')' .
		= '(' type_name initializer ')' .
		= '(' named_parameter_type_list ')' .
> .
named_parameter_type_list	= <
		= parameter_list .
		= parameter_list comma_opt_ellipsis .
		= type_name comma_opt_ellipsis .
		= type_name initializer comma_opt_ellipsis .
		= '...' .
> .
comma_opt_ellipsis	= <
		= '...' .
		= ',' '...' .
> .
parameter_list	= <
		= non_casting_parameter_declaration .
		= non_casting_parameter_declaration initializer .
		= type_name ',' parameter_declaration .
		= type_name initializer ',' parameter_declaration .
		= parameter_list ',' parameter_declaration .
> .
parameter_declaration	= <
		= type_name .
		= type_name initializer .
		= non_casting_parameter_declaration .
		= non_casting_parameter_declaration initializer .
> .
non_casting_parameter_declaration	= <
		= declaration_specifier .
		= declaration_specifier abstract_declarator .
		= declaration_specifier identifier_declarator .
		= declaration_specifier parameter_typedef_declarator .
		= declaration_qualifier_list .
		= declaration_qualifier_list abstract_declarator .
		= declaration_qualifier_list identifier_declarator .
		= type_specifier identifier_declarator .
		= type_specifier parameter_typedef_declarator .
		= basic_type_name identifier_declarator .
		= basic_type_name parameter_typedef_declarator .
		= TYPEDEFname identifier_declarator .
		= TYPEDEFname parameter_typedef_declarator .
		= global_or_scoped_typedefname identifier_declarator .
		= global_or_scoped_typedefname parameter_typedef_declarator .
		= type_qualifier_list identifier_declarator .
> .
type_name	= <
		= type_specifier .
		= basic_type_name .
		= TYPEDEFname .
		= global_or_scoped_typedefname .
		= type_qualifier_list .
		= type_specifier abstract_declarator .
		= basic_type_name abstract_declarator .
		= TYPEDEFname abstract_declarator .
		= global_or_scoped_typedefname abstract_declarator .
		= type_qualifier_list abstract_declarator .
> .
initializer_opt	= <
		= .
		= initializer .
> .
initializer	= '=' initializer_group .

initializer_group	= <
		= '{' initializer_list '}' .
		= '{' initializer_list ',' '}' .
		= assignment_expression .
> .
initializer_list	= <
		= initializer_group .
		= initializer_list ',' initializer_group .
> .
statement	= <
		= labeled_statement .
		= compound_statement .
		= expression_statement .
		= selection_statement .
		= iteration_statement .
		= jump_statement .
		= declaration .
> .
labeled_statement	= <
		= label ':' statement .
		= case constant_expression ':' statement .
		= default ':' statement .
> .
compound_statement	= '{' statement_list_opt '}' .

declaration_list	= <
		= declaration .
		= declaration_list declaration .
> .
statement_list_opt	= <
		= .
		= statement_list_opt statement .
> .
expression_statement	= comma_expression_opt ';' .

selection_statement	= <
		= if '(' comma_expression ')' statement .
		= if '(' comma_expression ')' statement else statement .
		= switch '(' comma_expression ')' statement .
> .
iteration_statement	= <
		= while '(' comma_expression_opt ')' statement .
		= do statement while '(' comma_expression ')' ';' .
		= for '(' comma_expression_opt ';' comma_expression_opt ';' comma_expression_opt ')' statement .
		= for '(' declaration comma_expression_opt ';' comma_expression_opt ')' statement .
> .
jump_statement	= <
		= goto label ';' .
		= continue ';' .
		= break ';' .
		= return comma_expression_opt ';' .
> .
label		= <
		= IDENTIFIER .
		= TYPEDEFname .
> .
translation_unit	= <
		= .
		= translation_unit external_definition .
> .
external_definition	= <
		= function_declaration .
		= function_definition .
		= declaration .
		= linkage_specifier function_declaration .
		= linkage_specifier function_definition .
		= linkage_specifier declaration .
		= linkage_specifier '{' translation_unit '}' .
> .
linkage_specifier	= extern STRINGliteral .

function_declaration	= <
		= identifier_declarator ';' .
		= constructor_function_declaration ';' .
> .
function_definition	= <
		= new_function_definition .
		= old_function_definition .
		= constructor_function_definition .
> .
new_function_definition	= <
		= identifier_declarator compound_statement .
		= declaration_specifier declarator compound_statement .
		= type_specifier declarator compound_statement .
		= basic_type_name declarator compound_statement .
		= TYPEDEFname declarator compound_statement .
		= global_or_scoped_typedefname declarator compound_statement .
		= declaration_qualifier_list identifier_declarator compound_statement .
		= type_qualifier_list identifier_declarator compound_statement .
> .
old_function_definition	= <
		= old_function_declarator old_function_body .
		= declaration_specifier old_function_declarator old_function_body .
		= type_specifier old_function_declarator old_function_body .
		= basic_type_name old_function_declarator old_function_body .
		= TYPEDEFname old_function_declarator old_function_body .
		= global_or_scoped_typedefname old_function_declarator old_function_body .
		= declaration_qualifier_list old_function_declarator old_function_body .
		= type_qualifier_list old_function_declarator old_function_body .
> .
old_function_body	= <
		= declaration_list compound_statement .
		= compound_statement .
> .
constructor_function_definition	= <
		= global_or_scoped_typedefname parameter_type_list constructor_init_list_opt compound_statement .
		= declaration_specifier parameter_type_list constructor_init_list_opt compound_statement .
> .
constructor_function_declaration	= <
		= global_or_scoped_typedefname parameter_type_list .
		= declaration_specifier parameter_type_list .
> .
constructor_function_in_class	= <
		= declaration_specifier constructor_parameter_list_and_body .
		= TYPEDEFname constructor_parameter_list_and_body .
> .
constructor_parameter_list_and_body	= <
		= '(' ')' type_qualifier_list_opt ';' .
		= '(' type_name initializer ')' type_qualifier_list_opt ';' .
		= '(' named_parameter_type_list ')' type_qualifier_list_opt ';' .
		= '(' ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' type_name initializer ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' named_parameter_type_list ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= constructor_conflicting_parameter_list_and_body .
> .
constructor_conflicting_parameter_list_and_body	= <
		= '(' type_specifier ')' type_qualifier_list_opt ';' .
		= '(' basic_type_name ')' type_qualifier_list_opt ';' .
		= '(' TYPEDEFname ')' type_qualifier_list_opt ';' .
		= '(' global_or_scoped_typedefname ')' type_qualifier_list_opt ';' .
		= '(' type_qualifier_list ')' type_qualifier_list_opt ';' .
		= '(' type_specifier abstract_declarator ')' type_qualifier_list_opt ';' .
		= '(' basic_type_name abstract_declarator ')' type_qualifier_list_opt ';' .
		= '(' global_or_scoped_typedefname abstract_declarator ')' type_qualifier_list_opt ';' .
		= '(' type_qualifier_list abstract_declarator ')' type_qualifier_list_opt ';' .
		= '(' type_specifier ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' basic_type_name ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' TYPEDEFname ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' global_or_scoped_typedefname ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' type_qualifier_list ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' type_specifier abstract_declarator ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' basic_type_name abstract_declarator ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' global_or_scoped_typedefname abstract_declarator ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' type_qualifier_list abstract_declarator ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= constructor_conflicting_typedef_declarator .
> .
constructor_conflicting_typedef_declarator	= <
		= '(' TYPEDEFname unary_abstract_declarator ')' type_qualifier_list_opt ';' .
		= '(' TYPEDEFname unary_abstract_declarator ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' TYPEDEFname postfix_abstract_declarator ')' type_qualifier_list_opt ';' .
		= '(' TYPEDEFname postfix_abstract_declarator ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
		= '(' TYPEDEFname postfixing_abstract_declarator ')' type_qualifier_list_opt ';' .
		= '(' TYPEDEFname postfixing_abstract_declarator ')' type_qualifier_list_opt constructor_init_list_opt compound_statement .
> .
constructor_init_list_opt	= <
		= .
		= constructor_init_list .
> .
constructor_init_list	= <
		= ':' constructor_init .
		= constructor_init_list ',' constructor_init .
> .
constructor_init	= <
		= IDENTIFIER '(' argument_expression_list ')' .
		= IDENTIFIER '(' ')' .
		= TYPEDEFname '(' argument_expression_list ')' .
		= TYPEDEFname '(' ')' .
		= global_or_scoped_typedefname '(' argument_expression_list ')' .
		= global_or_scoped_typedefname '(' ')' .
		= '(' argument_expression_list ')' .
		= '(' ')' .
> .
declarator	= <
		= identifier_declarator .
		= typedef_declarator .
> .
typedef_declarator	= <
		= paren_typedef_declarator .
		= simple_paren_typedef_declarator .
		= parameter_typedef_declarator .
> .
parameter_typedef_declarator	= <
		= TYPEDEFname .
		= TYPEDEFname postfixing_abstract_declarator .
		= clean_typedef_declarator .
> .
clean_typedef_declarator	= <
		= clean_postfix_typedef_declarator .
		= asterisk_or_ampersand parameter_typedef_declarator .
		= unary_modifier parameter_typedef_declarator .
> .
clean_postfix_typedef_declarator	= <
		= '(' clean_typedef_declarator ')' .
		= '(' clean_typedef_declarator ')' postfixing_abstract_declarator .
> .
paren_typedef_declarator	= <
		= postfix_paren_typedef_declarator .
		= asterisk_or_ampersand '(' simple_paren_typedef_declarator ')' .
		= unary_modifier '(' simple_paren_typedef_declarator ')' .
		= asterisk_or_ampersand '(' TYPEDEFname ')' .
		= unary_modifier '(' TYPEDEFname ')' .
		= asterisk_or_ampersand paren_typedef_declarator .
		= unary_modifier paren_typedef_declarator .
> .
postfix_paren_typedef_declarator	= <
		= '(' paren_typedef_declarator ')' .
		= '(' simple_paren_typedef_declarator postfixing_abstract_declarator ')' .
		= '(' TYPEDEFname postfixing_abstract_declarator ')' .
		= '(' paren_typedef_declarator ')' postfixing_abstract_declarator .
> .
simple_paren_typedef_declarator	= <
		= '(' TYPEDEFname ')' .
		= '(' simple_paren_typedef_declarator ')' .
> .
identifier_declarator	= <
		= unary_identifier_declarator .
		= paren_identifier_declarator .
> .
unary_identifier_declarator	= <
		= postfix_identifier_declarator .
		= asterisk_or_ampersand identifier_declarator .
		= unary_modifier identifier_declarator .
> .
postfix_identifier_declarator	= <
		= paren_identifier_declarator postfixing_abstract_declarator .
		= '(' unary_identifier_declarator ')' .
		= '(' unary_identifier_declarator ')' postfixing_abstract_declarator .
> .
old_function_declarator	= <
		= postfix_old_function_declarator .
		= asterisk_or_ampersand old_function_declarator .
		= unary_modifier old_function_declarator .
> .
postfix_old_function_declarator	= <
		= paren_identifier_declarator '(' argument_expression_list ')' .
		= '(' old_function_declarator ')' .
		= '(' old_function_declarator ')' old_postfixing_abstract_declarator .
> .
old_postfixing_abstract_declarator	= <
		= array_abstract_declarator .
		= old_parameter_type_list .
> .
abstract_declarator	= <
		= unary_abstract_declarator .
		= postfix_abstract_declarator .
		= postfixing_abstract_declarator .
> .
postfixing_abstract_declarator	= <
		= array_abstract_declarator .
		= parameter_type_list .
> .
array_abstract_declarator	= <
		= '[' ']' .
		= '[' constant_expression ']' .
		= array_abstract_declarator '[' constant_expression ']' .
> .
unary_abstract_declarator	= <
		= asterisk_or_ampersand .
		= unary_modifier .
		= asterisk_or_ampersand abstract_declarator .
		= unary_modifier abstract_declarator .
> .
postfix_abstract_declarator	= <
		= '(' unary_abstract_declarator ')' .
		= '(' postfix_abstract_declarator ')' .
		= '(' postfixing_abstract_declarator ')' .
		= '(' unary_abstract_declarator ')' postfixing_abstract_declarator .
> .
asterisk_or_ampersand	= <
		= '*' .
		= '&' .
> .
unary_modifier	= <
		= scope '*' type_qualifier_list_opt .
		= asterisk_or_ampersand type_qualifier_list .
> .
scoping_name	= <
		= tag_name .
		= aggregate_key tag_name .
> .
scope		= <
		= scoping_name '::' .
		= scope scoping_name '::' .
> .
tag_name	= <
		= IDENTIFIER .
		= TYPEDEFname .
> .
global_scope	= '::' .

global_or_scope	= <
		= global_scope .
		= scope .
		= global_scope scope .
> .
scope_opt_identifier	= <
		= IDENTIFIER .
		= scope IDENTIFIER .
> .
scope_opt_complex_name	= <
		= complex_name .
		= scope complex_name .
> .
complex_name	= <
		= '~' TYPEDEFname .
		= operator_function_name .
> .
global_opt_scope_opt_identifier	= <
		= global_scope scope_opt_identifier .
		= scope_opt_identifier .
> .
global_opt_scope_opt_complex_name	= <
		= global_scope scope_opt_complex_name .
		= scope_opt_complex_name .
> .
scoped_typedefname	= scope TYPEDEFname .

global_or_scoped_typedefname	= <
		= scoped_typedefname .
		= global_scope scoped_typedefname .
		= global_scope TYPEDEFname .
> .
global_opt_scope_opt_typedefname	= <
		= TYPEDEFname .
		= global_or_scoped_typedefname .
> .
Terminal		: [Dummy: us_char] { Dummy := ' '; } <
   IDENTIFIER		: .
   TYPEDEFname		: .
   CHARACTERconstant	: .
   FLOATINGconstant	: .
   HEXconstant		: .
   INTEGERconstant	: .
   OCTALconstant	: .
   STRINGliteral	: .
> .
